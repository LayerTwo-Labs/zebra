// @generated
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutPoint {
    #[prost(message, optional, tag="1")]
    pub txid: ::core::option::Option<super::super::common::v1::ReverseHex>,
    #[prost(message, optional, tag="2")]
    pub vout: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SidechainDeclaration {
    #[prost(oneof="sidechain_declaration::SidechainDeclaration", tags="1")]
    pub sidechain_declaration: ::core::option::Option<sidechain_declaration::SidechainDeclaration>,
}
/// Nested message and enum types in `SidechainDeclaration`.
pub mod sidechain_declaration {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct V0 {
        #[prost(message, optional, tag="1")]
        pub title: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, tag="2")]
        pub description: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, tag="3")]
        pub hash_id_1: ::core::option::Option<super::super::super::common::v1::ConsensusHex>,
        #[prost(message, optional, tag="4")]
        pub hash_id_2: ::core::option::Option<super::super::super::common::v1::Hex>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SidechainDeclaration {
        #[prost(message, tag="1")]
        V0(V0),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockHeaderInfo {
    #[prost(message, optional, tag="1")]
    pub block_hash: ::core::option::Option<super::super::common::v1::ReverseHex>,
    #[prost(message, optional, tag="2")]
    pub prev_block_hash: ::core::option::Option<super::super::common::v1::ReverseHex>,
    #[prost(uint32, tag="3")]
    pub height: u32,
    /// Total work as a uint256, little-endian
    #[prost(message, optional, tag="4")]
    pub work: ::core::option::Option<super::super::common::v1::ConsensusHex>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Deposit {
    #[prost(message, optional, tag="1")]
    pub sequence_number: ::core::option::Option<u64>,
    #[prost(message, optional, tag="2")]
    pub outpoint: ::core::option::Option<OutPoint>,
    #[prost(message, optional, tag="3")]
    pub output: ::core::option::Option<deposit::Output>,
}
/// Nested message and enum types in `Deposit`.
pub mod deposit {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Output {
        #[prost(message, optional, tag="2")]
        pub address: ::core::option::Option<super::super::super::common::v1::Hex>,
        #[prost(message, optional, tag="3")]
        pub value_sats: ::core::option::Option<u64>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WithdrawalBundleEvent {
    #[prost(message, optional, tag="1")]
    pub m6id: ::core::option::Option<super::super::common::v1::ConsensusHex>,
    #[prost(message, optional, tag="2")]
    pub event: ::core::option::Option<withdrawal_bundle_event::Event>,
}
/// Nested message and enum types in `WithdrawalBundleEvent`.
pub mod withdrawal_bundle_event {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Event {
        #[prost(oneof="event::Event", tags="1, 2, 3")]
        pub event: ::core::option::Option<event::Event>,
    }
    /// Nested message and enum types in `Event`.
    pub mod event {
        #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Failed {
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Succeeded {
            #[prost(message, optional, tag="1")]
            pub sequence_number: ::core::option::Option<u64>,
            #[prost(message, optional, tag="2")]
            pub transaction: ::core::option::Option<super::super::super::super::common::v1::ConsensusHex>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Submitted {
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Event {
            #[prost(message, tag="1")]
            Failed(Failed),
            #[prost(message, tag="2")]
            Succeeded(Succeeded),
            #[prost(message, tag="3")]
            Submitted(Submitted),
        }
    }
}
/// Specific to an individual sidechain slot
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockInfo {
    /// repeated Deposit deposits = 1;
    /// repeated WithdrawalBundleEvent withdrawal_bundle_events = 2;
    #[prost(message, optional, tag="1")]
    pub bmm_commitment: ::core::option::Option<super::super::common::v1::ConsensusHex>,
    #[prost(message, repeated, tag="2")]
    pub events: ::prost::alloc::vec::Vec<block_info::Event>,
}
/// Nested message and enum types in `BlockInfo`.
pub mod block_info {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Event {
        #[prost(oneof="event::Event", tags="1, 2")]
        pub event: ::core::option::Option<event::Event>,
    }
    /// Nested message and enum types in `Event`.
    pub mod event {
        #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Event {
            #[prost(message, tag="1")]
            Deposit(super::super::Deposit),
            #[prost(message, tag="2")]
            WithdrawalBundle(super::super::WithdrawalBundleEvent),
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlockHeaderInfoRequest {
    #[prost(message, optional, tag="1")]
    pub block_hash: ::core::option::Option<super::super::common::v1::ReverseHex>,
    /// Request block header info for up to `max_ancestors` ancestors.
    /// Fewer ancestors MAY be returned.
    #[prost(uint32, optional, tag="2")]
    pub max_ancestors: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlockHeaderInfoResponse {
    #[prost(message, optional, tag="1")]
    pub header_info: ::core::option::Option<BlockHeaderInfo>,
    /// Ancestors MUST be sorted newest-first
    #[prost(message, repeated, tag="2")]
    pub ancestor_infos: ::prost::alloc::vec::Vec<BlockHeaderInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlockInfoRequest {
    /// The block to fetch information about.
    #[prost(message, optional, tag="1")]
    pub block_hash: ::core::option::Option<super::super::common::v1::ReverseHex>,
    /// The sidechain to filter for events relating to. 
    #[prost(message, optional, tag="2")]
    pub sidechain_id: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlockInfoResponse {
    /// Information about the block itself.
    #[prost(message, optional, tag="1")]
    pub header_info: ::core::option::Option<BlockHeaderInfo>,
    /// Information about the block, filtered for events relating to 
    /// a specific sidechain.
    #[prost(message, optional, tag="2")]
    pub block_info: ::core::option::Option<BlockInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBmmHStarCommitmentRequest {
    #[prost(message, optional, tag="1")]
    pub block_hash: ::core::option::Option<super::super::common::v1::ReverseHex>,
    #[prost(message, optional, tag="2")]
    pub sidechain_id: ::core::option::Option<u32>,
    /// Request commitments for up to `max_ancestors` ancestors.
    /// Fewer ancestors MAY be returned.
    #[prost(uint32, optional, tag="3")]
    pub max_ancestors: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBmmHStarCommitmentResponse {
    #[prost(oneof="get_bmm_h_star_commitment_response::Result", tags="1, 2")]
    pub result: ::core::option::Option<get_bmm_h_star_commitment_response::Result>,
}
/// Nested message and enum types in `GetBmmHStarCommitmentResponse`.
pub mod get_bmm_h_star_commitment_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BlockNotFoundError {
        #[prost(message, optional, tag="1")]
        pub block_hash: ::core::option::Option<super::super::super::common::v1::ReverseHex>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct OptionalCommitment {
        #[prost(message, optional, tag="1")]
        pub commitment: ::core::option::Option<super::super::super::common::v1::ConsensusHex>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Commitment {
        #[prost(message, optional, tag="1")]
        pub commitment: ::core::option::Option<super::super::super::common::v1::ConsensusHex>,
        /// Ancestors MUST be sorted newest-first
        #[prost(message, repeated, tag="2")]
        pub ancestor_commitments: ::prost::alloc::vec::Vec<OptionalCommitment>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag="1")]
        BlockNotFound(BlockNotFoundError),
        #[prost(message, tag="2")]
        Commitment(Commitment),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetChainInfoRequest {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetChainInfoResponse {
    #[prost(enumeration="Network", tag="1")]
    pub network: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetChainTipRequest {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetChainTipResponse {
    #[prost(message, optional, tag="1")]
    pub block_header_info: ::core::option::Option<BlockHeaderInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCoinbasePsbtRequest {
    #[prost(message, repeated, tag="1")]
    pub propose_sidechains: ::prost::alloc::vec::Vec<get_coinbase_psbt_request::ProposeSidechain>,
    #[prost(message, repeated, tag="2")]
    pub ack_sidechains: ::prost::alloc::vec::Vec<get_coinbase_psbt_request::AckSidechain>,
    #[prost(message, repeated, tag="3")]
    pub propose_bundles: ::prost::alloc::vec::Vec<get_coinbase_psbt_request::ProposeBundle>,
    #[prost(message, optional, tag="4")]
    pub ack_bundles: ::core::option::Option<get_coinbase_psbt_request::AckBundles>,
}
/// Nested message and enum types in `GetCoinbasePSBTRequest`.
pub mod get_coinbase_psbt_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ProposeSidechain {
        #[prost(message, optional, tag="1")]
        pub sidechain_number: ::core::option::Option<u32>,
        #[prost(message, optional, tag="2")]
        pub data: ::core::option::Option<super::super::super::common::v1::ConsensusHex>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AckSidechain {
        #[prost(message, optional, tag="1")]
        pub sidechain_number: ::core::option::Option<u32>,
        #[prost(message, optional, tag="2")]
        pub data_hash: ::core::option::Option<super::super::super::common::v1::ConsensusHex>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ProposeBundle {
        #[prost(message, optional, tag="1")]
        pub sidechain_number: ::core::option::Option<u32>,
        #[prost(message, optional, tag="2")]
        pub bundle_txid: ::core::option::Option<super::super::super::common::v1::ReverseHex>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AckBundles {
        #[prost(oneof="ack_bundles::AckBundles", tags="1, 2, 3")]
        pub ack_bundles: ::core::option::Option<ack_bundles::AckBundles>,
    }
    /// Nested message and enum types in `AckBundles`.
    pub mod ack_bundles {
        #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct RepeatPrevious {
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct LeadingBy50 {
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Upvotes {
            #[prost(uint32, repeated, tag="1")]
            pub upvotes: ::prost::alloc::vec::Vec<u32>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum AckBundles {
            #[prost(message, tag="1")]
            RepeatPrevious(RepeatPrevious),
            #[prost(message, tag="2")]
            LeadingBy50(LeadingBy50),
            #[prost(message, tag="3")]
            Upvotes(Upvotes),
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCoinbasePsbtResponse {
    #[prost(message, optional, tag="1")]
    pub psbt: ::core::option::Option<super::super::common::v1::ConsensusHex>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetCtipRequest {
    #[prost(message, optional, tag="1")]
    pub sidechain_number: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCtipResponse {
    #[prost(message, optional, tag="1")]
    pub ctip: ::core::option::Option<get_ctip_response::Ctip>,
}
/// Nested message and enum types in `GetCtipResponse`.
pub mod get_ctip_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Ctip {
        #[prost(message, optional, tag="1")]
        pub txid: ::core::option::Option<super::super::super::common::v1::ReverseHex>,
        #[prost(uint32, tag="2")]
        pub vout: u32,
        #[prost(uint64, tag="3")]
        pub value: u64,
        #[prost(uint64, tag="4")]
        pub sequence_number: u64,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetSidechainProposalsRequest {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSidechainProposalsResponse {
    #[prost(message, repeated, tag="1")]
    pub sidechain_proposals: ::prost::alloc::vec::Vec<get_sidechain_proposals_response::SidechainProposal>,
}
/// Nested message and enum types in `GetSidechainProposalsResponse`.
pub mod get_sidechain_proposals_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SidechainProposal {
        #[prost(message, optional, tag="1")]
        pub sidechain_number: ::core::option::Option<u32>,
        /// Raw sidechain proposal description
        #[prost(message, optional, tag="2")]
        pub description: ::core::option::Option<super::super::super::common::v1::ConsensusHex>,
        /// Sidechain data, as declared in the M1 proposal.
        /// Might be nil, if the proposal uses an unknown version.
        #[prost(message, optional, tag="7")]
        pub declaration: ::core::option::Option<super::SidechainDeclaration>,
        #[prost(message, optional, tag="3")]
        pub description_sha256d_hash: ::core::option::Option<super::super::super::common::v1::ReverseHex>,
        #[prost(message, optional, tag="4")]
        pub vote_count: ::core::option::Option<u32>,
        #[prost(message, optional, tag="5")]
        pub proposal_height: ::core::option::Option<u32>,
        #[prost(message, optional, tag="6")]
        pub proposal_age: ::core::option::Option<u32>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetSidechainsRequest {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSidechainsResponse {
    #[prost(message, repeated, tag="1")]
    pub sidechains: ::prost::alloc::vec::Vec<get_sidechains_response::SidechainInfo>,
}
/// Nested message and enum types in `GetSidechainsResponse`.
pub mod get_sidechains_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SidechainInfo {
        #[prost(message, optional, tag="1")]
        pub sidechain_number: ::core::option::Option<u32>,
        #[prost(message, optional, tag="2")]
        pub description: ::core::option::Option<super::super::super::common::v1::ConsensusHex>,
        #[prost(message, optional, tag="3")]
        pub vote_count: ::core::option::Option<u32>,
        #[prost(message, optional, tag="4")]
        pub proposal_height: ::core::option::Option<u32>,
        #[prost(message, optional, tag="5")]
        pub activation_height: ::core::option::Option<u32>,
        /// Sidechain data, as declared in the M1 proposal.
        /// Might be nil, if the proposal uses an unknown version.
        #[prost(message, optional, tag="6")]
        pub declaration: ::core::option::Option<super::SidechainDeclaration>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTwoWayPegDataRequest {
    #[prost(message, optional, tag="1")]
    pub sidechain_id: ::core::option::Option<u32>,
    #[prost(message, optional, tag="2")]
    pub start_block_hash: ::core::option::Option<super::super::common::v1::ReverseHex>,
    #[prost(message, optional, tag="3")]
    pub end_block_hash: ::core::option::Option<super::super::common::v1::ReverseHex>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTwoWayPegDataResponse {
    #[prost(message, repeated, tag="1")]
    pub blocks: ::prost::alloc::vec::Vec<get_two_way_peg_data_response::ResponseItem>,
}
/// Nested message and enum types in `GetTwoWayPegDataResponse`.
pub mod get_two_way_peg_data_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ResponseItem {
        #[prost(message, optional, tag="1")]
        pub block_header_info: ::core::option::Option<super::BlockHeaderInfo>,
        #[prost(message, optional, tag="2")]
        pub block_info: ::core::option::Option<super::BlockInfo>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubscribeEventsRequest {
    #[prost(message, optional, tag="1")]
    pub sidechain_id: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeEventsResponse {
    #[prost(message, optional, tag="1")]
    pub event: ::core::option::Option<subscribe_events_response::Event>,
}
/// Nested message and enum types in `SubscribeEventsResponse`.
pub mod subscribe_events_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Event {
        #[prost(oneof="event::Event", tags="1, 2")]
        pub event: ::core::option::Option<event::Event>,
    }
    /// Nested message and enum types in `Event`.
    pub mod event {
        #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ConnectBlock {
            #[prost(message, optional, tag="1")]
            pub header_info: ::core::option::Option<super::super::BlockHeaderInfo>,
            #[prost(message, optional, tag="2")]
            pub block_info: ::core::option::Option<super::super::BlockInfo>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
        pub struct DisconnectBlock {
            #[prost(message, optional, tag="1")]
            pub block_hash: ::core::option::Option<super::super::super::super::common::v1::ReverseHex>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Event {
            #[prost(message, tag="1")]
            ConnectBlock(ConnectBlock),
            #[prost(message, tag="2")]
            DisconnectBlock(DisconnectBlock),
        }
    }
}
/// Empty for now, could add filters later
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubscribeHeaderSyncProgressRequest {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubscribeHeaderSyncProgressResponse {
    /// Current sync height may be unknown at the start of a sync
    #[prost(message, optional, tag="1")]
    pub current_height: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Network {
    Unspecified = 0,
    Unknown = 1,
    Mainnet = 2,
    Regtest = 3,
    Signet = 4,
    Testnet = 5,
}
impl Network {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Network::Unspecified => "NETWORK_UNSPECIFIED",
            Network::Unknown => "NETWORK_UNKNOWN",
            Network::Mainnet => "NETWORK_MAINNET",
            Network::Regtest => "NETWORK_REGTEST",
            Network::Signet => "NETWORK_SIGNET",
            Network::Testnet => "NETWORK_TESTNET",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NETWORK_UNSPECIFIED" => Some(Self::Unspecified),
            "NETWORK_UNKNOWN" => Some(Self::Unknown),
            "NETWORK_MAINNET" => Some(Self::Mainnet),
            "NETWORK_REGTEST" => Some(Self::Regtest),
            "NETWORK_SIGNET" => Some(Self::Signet),
            "NETWORK_TESTNET" => Some(Self::Testnet),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WalletTransaction {
    #[prost(message, optional, tag="1")]
    pub txid: ::core::option::Option<super::super::common::v1::ReverseHex>,
    #[prost(uint64, tag="2")]
    pub fee_sats: u64,
    #[prost(uint64, tag="3")]
    pub received_sats: u64,
    #[prost(uint64, tag="4")]
    pub sent_sats: u64,
    #[prost(message, optional, tag="5")]
    pub confirmation_info: ::core::option::Option<wallet_transaction::Confirmation>,
}
/// Nested message and enum types in `WalletTransaction`.
pub mod wallet_transaction {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Confirmation {
        #[prost(uint32, tag="1")]
        pub height: u32,
        #[prost(message, optional, tag="2")]
        pub block_hash: ::core::option::Option<super::super::super::common::v1::ReverseHex>,
        #[prost(message, optional, tag="3")]
        pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BroadcastWithdrawalBundleRequest {
    #[prost(message, optional, tag="1")]
    pub sidechain_id: ::core::option::Option<u32>,
    #[prost(message, optional, tag="2")]
    pub transaction: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BroadcastWithdrawalBundleResponse {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBmmCriticalDataTransactionRequest {
    #[prost(message, optional, tag="1")]
    pub sidechain_id: ::core::option::Option<u32>,
    #[prost(message, optional, tag="2")]
    pub value_sats: ::core::option::Option<u64>,
    #[prost(message, optional, tag="3")]
    pub height: ::core::option::Option<u32>,
    #[prost(message, optional, tag="4")]
    pub critical_hash: ::core::option::Option<super::super::common::v1::ConsensusHex>,
    #[prost(message, optional, tag="5")]
    pub prev_bytes: ::core::option::Option<super::super::common::v1::ReverseHex>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBmmCriticalDataTransactionResponse {
    #[prost(message, optional, tag="1")]
    pub txid: ::core::option::Option<super::super::common::v1::ReverseHex>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDepositTransactionRequest {
    #[prost(message, optional, tag="1")]
    pub sidechain_id: ::core::option::Option<u32>,
    /// Addresses are encoded in UTF8.
    /// *Sidechain deposit addresses* (not sidechain addresses) are typically
    /// formatted as `s<SLOT_NUMBER>_<ADDRESS>_<CHECKSUM>`,
    /// where `CHECKSUM` is a hex encoding of the first 6 bytes of the SHA256
    /// hash of `s<SLOT_NUMBER>_<ADDRESS>`.
    /// protolint:disable:next MAX_LINE_LENGTH
    /// <https://github.com/LayerTwo-Labs/testchain-deprecated/blob/4b7bae3e1218e058f59a43caf6ccac2a4e9a91f6/src/sidechain.cpp#L219>
    /// The address used here is a sidechain address, the middle component of a
    /// sidechain deposit address.
    #[prost(message, optional, tag="2")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="3")]
    pub value_sats: ::core::option::Option<u64>,
    #[prost(message, optional, tag="4")]
    pub fee_sats: ::core::option::Option<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDepositTransactionResponse {
    #[prost(message, optional, tag="1")]
    pub txid: ::core::option::Option<super::super::common::v1::ReverseHex>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateNewAddressRequest {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateNewAddressResponse {
    #[prost(string, tag="1")]
    pub address: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSidechainProposalRequest {
    #[prost(message, optional, tag="1")]
    pub sidechain_id: ::core::option::Option<u32>,
    #[prost(message, optional, tag="2")]
    pub declaration: ::core::option::Option<SidechainDeclaration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSidechainProposalResponse {
    #[prost(oneof="create_sidechain_proposal_response::Event", tags="1, 2")]
    pub event: ::core::option::Option<create_sidechain_proposal_response::Event>,
}
/// Nested message and enum types in `CreateSidechainProposalResponse`.
pub mod create_sidechain_proposal_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Confirmed {
        #[prost(message, optional, tag="1")]
        pub block_hash: ::core::option::Option<super::super::super::common::v1::ReverseHex>,
        #[prost(message, optional, tag="2")]
        pub confirmations: ::core::option::Option<u32>,
        #[prost(message, optional, tag="3")]
        pub height: ::core::option::Option<u32>,
        #[prost(message, optional, tag="4")]
        pub outpoint: ::core::option::Option<super::OutPoint>,
        #[prost(message, optional, tag="5")]
        pub prev_block_hash: ::core::option::Option<super::super::super::common::v1::ReverseHex>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NotConfirmed {
        #[prost(message, optional, tag="1")]
        pub block_hash: ::core::option::Option<super::super::super::common::v1::ReverseHex>,
        #[prost(message, optional, tag="2")]
        pub height: ::core::option::Option<u32>,
        #[prost(message, optional, tag="3")]
        pub prev_block_hash: ::core::option::Option<super::super::super::common::v1::ReverseHex>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag="1")]
        Confirmed(Confirmed),
        #[prost(message, tag="2")]
        NotConfirmed(NotConfirmed),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateWalletRequest {
    /// BIP39 mnemonic. 12 or 24 words.
    #[prost(string, repeated, tag="1")]
    pub mnemonic_words: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Path to a file containing the mnemonic. 
    #[prost(string, tag="2")]
    pub mnemonic_path: ::prost::alloc::string::String,
    /// Password for the wallet. Used to encrypt the mnemonic in storage.
    /// NOT a BIP39 passphrase.
    #[prost(string, tag="3")]
    pub password: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateWalletResponse {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetBalanceRequest {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetBalanceResponse {
    #[prost(uint64, tag="1")]
    pub confirmed_sats: u64,
    #[prost(uint64, tag="2")]
    pub pending_sats: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListSidechainDepositTransactionsRequest {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSidechainDepositTransactionsResponse {
    #[prost(message, repeated, tag="1")]
    pub transactions: ::prost::alloc::vec::Vec<list_sidechain_deposit_transactions_response::SidechainDepositTransaction>,
}
/// Nested message and enum types in `ListSidechainDepositTransactionsResponse`.
pub mod list_sidechain_deposit_transactions_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SidechainDepositTransaction {
        #[prost(message, optional, tag="1")]
        pub sidechain_number: ::core::option::Option<u32>,
        #[prost(message, optional, tag="2")]
        pub tx: ::core::option::Option<super::WalletTransaction>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListTransactionsRequest {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTransactionsResponse {
    #[prost(message, repeated, tag="1")]
    pub transactions: ::prost::alloc::vec::Vec<WalletTransaction>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendTransactionRequest {
    /// Address -> satoshi amount
    #[prost(map="string, uint64", tag="1")]
    pub destinations: ::std::collections::HashMap<::prost::alloc::string::String, u64>,
    /// If not set, a reasonable rate is used by asking Core for an estimate.
    #[prost(message, optional, tag="2")]
    pub fee_rate: ::core::option::Option<send_transaction_request::FeeRate>,
    /// if set, the transaction will add a separate OP_RETURN output with this
    /// message.
    #[prost(message, optional, tag="3")]
    pub op_return_message: ::core::option::Option<super::super::common::v1::Hex>,
    /// UTXOs that must be included in the transaction. Incompatible with
    /// specifying a draining address.
    #[prost(message, repeated, tag="4")]
    pub required_utxos: ::prost::alloc::vec::Vec<send_transaction_request::RequiredUtxo>,
    /// If set, the transaction will send all UTXOs in the wallet to this address.
    /// Incompatible with specifying required UTXOs.
    #[prost(string, optional, tag="5")]
    pub drain_wallet_to: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `SendTransactionRequest`.
pub mod send_transaction_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct FeeRate {
        #[prost(oneof="fee_rate::Fee", tags="1, 2")]
        pub fee: ::core::option::Option<fee_rate::Fee>,
    }
    /// Nested message and enum types in `FeeRate`.
    pub mod fee_rate {
        #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Fee {
            /// Fee rate, measured in sat/vbyte.
            #[prost(uint64, tag="1")]
            SatPerVbyte(u64),
            /// Fee amount, measured in sats.
            #[prost(uint64, tag="2")]
            Sats(u64),
        }
    }
    /// A previous unspent transaction output that must be included in the
    /// transaction.
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RequiredUtxo {
        #[prost(message, optional, tag="1")]
        pub txid: ::core::option::Option<super::super::super::common::v1::ReverseHex>,
        #[prost(uint32, tag="2")]
        pub vout: u32,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendTransactionResponse {
    #[prost(message, optional, tag="1")]
    pub txid: ::core::option::Option<super::super::common::v1::ReverseHex>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnlockWalletRequest {
    #[prost(string, tag="1")]
    pub password: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnlockWalletResponse {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GenerateBlocksRequest {
    /// Number of blocks to generate. 
    #[prost(message, optional, tag="1")]
    pub blocks: ::core::option::Option<u32>,
    /// ACK all sidechain proposals, irregardless of if they are already 
    /// in the wallet DB. 
    #[prost(bool, tag="2")]
    pub ack_all_proposals: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateBlocksResponse {
    #[prost(message, optional, tag="1")]
    pub block_hash: ::core::option::Option<super::super::common::v1::ReverseHex>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetInfoRequest {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInfoResponse {
    /// The network the wallet is on
    #[prost(string, tag="1")]
    pub network: ::prost::alloc::string::String,
    /// Total number of transactions in the wallet
    #[prost(uint32, tag="2")]
    pub transaction_count: u32,
    /// Number of UTXOs in the wallet.
    #[prost(uint32, tag="3")]
    pub unspent_output_count: u32,
    #[prost(map="string, string", tag="4")]
    pub descriptors: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListUnspentOutputsRequest {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUnspentOutputsResponse {
    #[prost(message, repeated, tag="1")]
    pub outputs: ::prost::alloc::vec::Vec<list_unspent_outputs_response::Output>,
}
/// Nested message and enum types in `ListUnspentOutputsResponse`.
pub mod list_unspent_outputs_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Output {
        #[prost(message, optional, tag="1")]
        pub txid: ::core::option::Option<super::super::super::common::v1::ReverseHex>,
        #[prost(uint32, tag="2")]
        pub vout: u32,
        #[prost(uint64, tag="3")]
        pub value_sats: u64,
        /// An internal output is one that was created by the wallet itself
        /// as change output for a transaction.
        #[prost(bool, tag="4")]
        pub is_internal: bool,
        #[prost(bool, tag="5")]
        pub is_confirmed: bool,
        #[prost(uint32, tag="6")]
        pub confirmed_at_block: u32,
        #[prost(message, optional, tag="7")]
        pub confirmed_at_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(message, optional, tag="8")]
        pub confirmed_transitively: ::core::option::Option<super::super::super::common::v1::ReverseHex>,
        #[prost(message, optional, tag="9")]
        pub unconfirmed_last_seen: ::core::option::Option<::prost_types::Timestamp>,
    }
}
include!("cusf.mainchain.v1.tonic.rs");
// @@protoc_insertion_point(module)